# 我的 12 小时冲刺计划

> **目标**: 一个人完成"探索不同物理场景"的核心代码和全部实验图表，让团队有东西可以直接写报告和做 PPT
>
> **总工时**: 12 小时 | **代码**: 4h | **跑实验+出图**: 6h | **整理**: 2h
>
> **最终产出**: `results/` 目录下 **6 组场景 × 每组 3-4 张图 = ~20 张成品图** + 一份对比总结

---

## 思路：改一个文件，出六组图

现有代码的结构已经很好。核心瓶颈只有一个：

> `pde_2d_model.py` 第 128-166 行 —— 四面墙的 Robin BC 全用同一个 `h_wall`

只要让 **每面墙的每个网格点可以用不同的 h 值**，窗户、门、不同保温等级的墙面就都能建模了。其余代码（求解器、控制器、绘图）不用动。

---

## Hour 1-2：改 `pde_2d_model.py`（核心，决定后面所有实验能不能跑）

### 目标：支持分段式边界条件 + 域 mask

#### 改动 1：h_wall 从标量 → 四个数组

```python
# 旧代码：
self.h_wall = h_wall  # 一个数字

# 新代码：四面墙各自一个 h 数组
# h_south[j], h_north[j]: 长度 nx，对应底边和顶边每个 x 网格点
# h_west[i],  h_east[i]:  长度 ny，对应左边和右边每个 y 网格点
```

**具体做法**：在 `__init__` 里加一个参数 `wall_h=None`

```python
def __init__(self, ..., wall_h=None, domain_mask=None):
    ...
    if wall_h is None:
        # 默认行为：和现在一样，四面墙统一 h
        self.h_south = np.full(nx, h_wall)
        self.h_north = np.full(nx, h_wall)
        self.h_west  = np.full(ny, h_wall)
        self.h_east  = np.full(ny, h_wall)
    else:
        self.h_south = wall_h.get('south', np.full(nx, h_wall))
        self.h_north = wall_h.get('north', np.full(nx, h_wall))
        self.h_west  = wall_h.get('west',  np.full(ny, h_wall))
        self.h_east  = wall_h.get('east',  np.full(ny, h_wall))

    # 域 mask（L 形用）
    if domain_mask is not None:
        self.mask = domain_mask  # shape (nx, ny), True=有效, False=被挖掉
    else:
        self.mask = np.ones((nx, ny), dtype=bool)
```

#### 改动 2：`rhs()` 函数中用数组 h 替代标量

```python
# 旧代码（以 bottom wall 为例）：
# - 2*dy*self.h_wall*(T[1:-1, 0] - self.T_a)

# 新代码：
# - 2*dy*self.h_south[1:-1]*(T[1:-1, 0] - self.T_a)
```

四面墙 + 四个角落都要改。**共约 12 处把 `self.h_wall` 替换成对应方向的数组切片**。

#### 改动 3：域 mask 处理

```python
# 在 rhs() 最后，apply mask
dTdt[~self.mask] = 0.0  # 被挖掉的区域温度不变（或设为 T_a）
```

#### 改动 4：时变 BC 支持（门的模型）

在 `rhs()` 开头加一行：

```python
# 如果 wall_h 有回调函数，每个时间步重新计算 h
if hasattr(self, '_h_updater') and self._h_updater is not None:
    self._h_updater(t, self)
```

这样门的开关就是一个 callback，在特定时间段把某段墙的 h 改成极大值（≈ Dirichlet）。

### 验证

改完后跑一下默认参数（全墙 h=0.5），确认结果和改之前一样。**这步必须做，否则后面全废。**

---

## Hour 3：写 6 个场景配置 + 统一运行脚本

### 在 `Code/` 下新建 `scenarios.py`

一个文件搞定所有场景，不用建目录：

```python
# scenarios.py — 所有场景的配置

import numpy as np
from utils.parameters import *

def make_baseline():
    """S1: 5x5 方形房间，南墙 Robin (外墙)，其余 Neumann (保温墙)"""
    wall_h = {
        'south': np.full(NX, H_WALL),   # 外墙
        'north': np.full(NX, 0.0),      # 保温墙 (h=0 → Neumann)
        'west':  np.full(NY, 0.0),
        'east':  np.full(NY, 0.0),
    }
    return {"name": "S1_Baseline", "Lx": 5, "Ly": 5, "wall_h": wall_h,
            "heater_pos": (2.5, 0.5), "thermostat_pos": (2.5, 2.5)}

def make_window():
    """S2: 南墙中间 2m 是窗户 (h = 5 × h_wall)"""
    h_south = np.full(NX, H_WALL)
    x = np.linspace(0, 5, NX)
    window_mask = (x >= 1.5) & (x <= 3.5)  # 中间 2m
    h_south[window_mask] = H_WALL * 5       # 窗户 h 更大
    wall_h = {'south': h_south, 'north': np.full(NX, 0.0),
              'west': np.full(NY, 0.0), 'east': np.full(NY, 0.0)}
    return {"name": "S2_Window", "Lx": 5, "Ly": 5, "wall_h": wall_h,
            "heater_pos": (2.5, 0.5), "thermostat_pos": (2.5, 2.5)}

def make_window_compare():
    """S3: 三种窗户 — 小窗(1m) / 大窗(3m) / 双层窗(低h)"""
    configs = []
    x = np.linspace(0, 5, NX)
    for label, center, width, h_mult in [
        ("Small_Window", 2.5, 1.0, 5),
        ("Large_Window", 2.5, 3.0, 5),
        ("Double_Glazing", 2.5, 2.0, 2),  # 双层窗 h 只有单层的 40%
    ]:
        h_south = np.full(NX, H_WALL)
        mask = (x >= center - width/2) & (x <= center + width/2)
        h_south[mask] = H_WALL * h_mult
        wall_h = {'south': h_south, 'north': np.full(NX, 0.0),
                  'west': np.full(NY, 0.0), 'east': np.full(NY, 0.0)}
        configs.append({"name": f"S3_{label}", "Lx": 5, "Ly": 5,
                       "wall_h": wall_h, "heater_pos": (2.5, 0.5),
                       "thermostat_pos": (2.5, 2.5)})
    return configs

def make_door_opening():
    """S4: 西墙有门，t=30min 打开，t=40min 关上"""
    def h_updater(t, model):
        h_west = np.full(model.ny, 0.0)  # 默认保温墙
        if 30 <= t <= 40:
            y = np.linspace(0, model.Ly, model.ny)
            door_mask = (y >= 1.0) & (y <= 2.5)  # 门 1.5m 宽
            h_west[door_mask] = 10.0  # 极大 h ≈ 直接暴露在室外
        model.h_west = h_west
    wall_h = {'south': np.full(NX, H_WALL), 'north': np.full(NX, 0.0),
              'west': np.full(NY, 0.0), 'east': np.full(NY, 0.0)}
    return {"name": "S4_Door", "Lx": 5, "Ly": 5, "wall_h": wall_h,
            "heater_pos": (2.5, 0.5), "thermostat_pos": (2.5, 2.5),
            "_h_updater": h_updater}

def make_narrow_room():
    """S5: 长窄房间 7.5 × 2.5m (等面积矩形，长宽比 3:1)"""
    nx_narrow = 76  # 保持网格密度
    ny_narrow = 26
    wall_h = {
        'south': np.full(nx_narrow, H_WALL),
        'north': np.full(nx_narrow, 0.0),
        'west':  np.full(ny_narrow, 0.0),
        'east':  np.full(ny_narrow, 0.0),
    }
    return {"name": "S5_Narrow", "Lx": 7.5, "Ly": 2.5,
            "nx": nx_narrow, "ny": ny_narrow, "wall_h": wall_h,
            "heater_pos": (3.75, 0.5), "thermostat_pos": (3.75, 1.25)}

def make_L_shape():
    """S6: L 形房间 — 5x5 去掉右上角 [2.5,5]×[2.5,5]"""
    mask = np.ones((NX, NY), dtype=bool)
    x = np.linspace(0, 5, NX)
    y = np.linspace(0, 5, NY)
    X, Y = np.meshgrid(x, y, indexing='ij')
    mask[(X >= 2.5) & (Y >= 2.5)] = False
    wall_h = {
        'south': np.full(NX, H_WALL),
        'north': np.full(NX, 0.0),
        'west':  np.full(NY, 0.0),
        'east':  np.full(NY, 0.0),
    }
    return {"name": "S6_L_Shape", "Lx": 5, "Ly": 5, "wall_h": wall_h,
            "domain_mask": mask,
            "heater_pos": (1.25, 0.5), "thermostat_pos": (1.25, 2.5)}
```

### 同时写 `experiments/exp_scenarios.py`

统一运行器：读取场景配置 → 创建模型 → 跑仿真 → 调用出图函数 → 保存到 `results/scenarios/`

---

## Hour 4：写出图函数

### 在 `utils/plotting.py` 里加 3 个函数

#### 函数 1: `plot_scenario_field(scenario_name, X, Y, T_final, heater_pos, therm_pos, mask=None, window_segments=None)`
- 2D 热力图 (pcolormesh)
- ★ 标加热器，× 标恒温器
- 窗户区域用**粗蓝线**标在边界上
- L 形 mask 区域涂灰
- colorbar 统一范围 [5, 25]°C

#### 函数 2: `plot_scenario_timeseries(t, T_mean, T_sensor, u, T_set=20)`
- 上半图：房间均温 + 恒温器读数 + T_set 虚线 + 舒适区间灰带 [18,26]
- 下半图：控制信号 u(t)

#### 函数 3: `plot_scenario_comparison(scenarios_data)`
- 输入: `[{"name": "S1", "T_field": ..., "metrics": {...}}, ...]`
- 输出 1: 1×N 温度场并排面板（N 个场景）
- 输出 2: 柱状图对比 RMSE + 能耗

---

## Hour 5-6：跑 S1 基线 + S2 窗户 + S3 窗户对比

### S1 基线 (30 min)

```bash
python experiments/exp_scenarios.py --scenario baseline
```

**出图**:
1. `S1_field.png` — 终态温度场
2. `S1_timeseries.png` — 温度 + 控制信号时间曲线

确认基线结果物理合理（外墙附近冷，室内暖），这是所有对比的参照。

### S2 窗户 (30 min)

```bash
python experiments/exp_scenarios.py --scenario window
```

**出图**:
1. `S2_field.png` — 终态温度场（窗户附近应该有明显冷区）
2. `S2_timeseries.png`
3. `S1_vs_S2_comparison.png` — 两个温度场并排 + 指标对比

**期望看到**: 窗户区域温度比基线低 2-5°C，加热器需要更多能耗来补偿。

### S3 窗户参数 (1h)

跑三组（小窗/大窗/双层窗），加上 S1 基线共 4 组对比

**出图**:
1. `S3_4panel_fields.png` — 1×4 面板（基线 / 小窗 / 大窗 / 双层窗）
2. `S3_metrics_bar.png` — 4 组的 RMSE + 能耗柱状图
3. `S3_window_size_vs_energy.png` — 窗户面积 vs 能耗的关系曲线

**关键结论**: 窗面积翻倍，能耗增加 X%；双层窗在同面积下节能 Y%。

---

## Hour 7-8：跑 S4 开门 + S5 长窄房间

### S4 开门通风 (1h)

**出图**:
1. `S4_door_snapshots.png` — 5 个时刻的温度场快照 (t=25, 30, 35, 40, 50 min)，能看到门打开→冷空气涌入→门关闭→温度恢复的过程
2. `S4_timeseries.png` — 温度曲线在 t=30 处骤降，t=40 后恢复
3. `S4_door_duration.png` — 门开 5min / 10min / 20min 三种情况的温度恢复对比

**期望看到**: 门开越久温度降越多，恢复时间更长。门附近温度降最猛。

### S5 长窄房间 (1h)

**出图**:
1. `S5_field.png` — 长窄房间温度场（远离加热器的一端应该冷）
2. `S5_vs_S1.png` — 和正方形并排对比
3. `S5_heater_position.png` — 加热器在左端/中间/右端的对比，看哪个位置覆盖最均匀

**期望看到**: 长窄房间的温度不均匀度远大于正方形，加热器放中间最优。

---

## Hour 9-10：跑 S6 L 形 + 全场景对比

### S6 L 形房间 (1h)

**出图**:
1. `S6_field.png` — L 形温度场，灰色遮罩被挖掉的区域
2. `S6_dead_corner.png` — 拐角区域温度分析（拐角平均温度 vs 全域平均温度）
3. `S6_heater_position.png` — 加热器在竖臂/横臂/拐角附近 3 个位置的对比

**期望看到**: L 形拐角温度比全域平均低 3-5°C。加热器靠近拐角时死角缓解。

### 全场景对比 (1h)

**出图**（最重要的几张，直接能上报告和 PPT）:
1. `ALL_6scenarios_fields.png` — 2×3 面板，6 个场景的终态温度场一览
2. `ALL_metrics_comparison.png` — 6 个场景的 RMSE / 能耗 / 不均匀度柱状图
3. `ALL_factor_ranking.png` — "哪个因素影响最大"排名图

**关键结论**（数据驱动）:
- 窗户大小对能耗影响 ~X%
- 门打开 10 分钟使温度下降 ~Y°C
- L 形房间不均匀度比正方形高 ~Z%
- 长窄房间的远端温差 ~W°C

---

## Hour 11：整理结果 + 写 key findings 文档

### 产出: `results/scenarios/key_findings.md`

```markdown
# 场景实验关键发现

## 1. 窗户效应
- 窗户使外墙附近温度降低 X°C
- 大窗(3m) vs 小窗(1m): 能耗增加 Y%
- 双层窗 vs 单层窗: 节能 Z%
- **最优加热器位置**: 应靠近窗户以补偿热损

## 2. 门的影响
- 开门 10min: 全域温度降 X°C，恢复需 Y min
- 门附近温降最剧烈，达 Z°C
- **实际启示**: 开门时间控制对能效影响显著

## 3. 房间形状
- 长窄房间 (3:1) vs 正方形: 不均匀度增加 X%
- L 形死角温度比全域低 Y°C
- **最优恒温器位置**: 不应放在加热器旁（会误判全域温度）

## 4. 因素影响排名
1. 房间形状（影响最大）
2. 窗户大小
3. 门通风
4. 双层窗隔热
```

这份文档是写作组写报告 §5-6 的直接输入。

---

## Hour 12：最终检查 + 打包交付

| 检查项 | 完成 |
|--------|------|
| 所有 .py 文件能 `python` 直接运行 | |
| `results/scenarios/` 下有全部 ~20 张图 | |
| 每张图有清晰的标题、标签、colorbar | |
| `key_findings.md` 写完 | |
| 代码 push 到 GitHub | |
| 在群里告诉队友"图出完了，可以开始写报告" | |

---

## 每小时检查点

| 时间 | 产出 | 如果卡住了 |
|------|------|-----------|
| **Hour 1** | `pde_2d_model.py` 改完分段 h，验证通过 | 先只改 south wall，其他三面后面改 |
| **Hour 2** | 域 mask + 时变 BC 完成 | mask 可以先跳过，L 形放最后做 |
| **Hour 3** | `scenarios.py` + `exp_scenarios.py` 写完 | 先手写 S1/S2 的脚本，不用统一运行器 |
| **Hour 4** | 3 个出图函数写完 | 先用最简单的 `plt.pcolormesh` 出图，美化放后面 |
| **Hour 5** | S1 基线 2 张图出齐 | 如果基线不对，停下来 debug，这是地基 |
| **Hour 6** | S2 + S3 共 5 张图 | 窗户对比先做 2 组，第 3 组不重要 |
| **Hour 7** | S4 开门 3 张图 | 时变 BC 有 bug → 简化为"门一直开"的静态场景 |
| **Hour 8** | S5 长窄 3 张图 | 只改 Lx/Ly，最简单的场景 |
| **Hour 9** | S6 L 形 3 张图 | mask 有 bug → 用矩形近似 L 形 |
| **Hour 10** | 全场景对比 3 张图 | 至少出 S1/S2/S5 三场景对比 |
| **Hour 11** | key_findings.md | 即使只有 4 个场景的数据也能写 |
| **Hour 12** | 代码推送 + 通知队友 | |

---

## 优先级（如果 12 小时不够）

**必须完成**（8 小时就能出活）:
1. ✅ 改 `pde_2d_model.py` 支持分段 h（Hour 1-2）
2. ✅ S1 基线 + S2 窗户 + S5 长窄房间（Hour 5-6, 8）—— 三场景对比就够写报告了
3. ✅ 全场景对比图（Hour 10）
4. ✅ key_findings.md（Hour 11）

**最好完成**:
5. S3 窗户参数对比（展示思考深度）
6. S4 开门通风（展示时变 BC 能力）

**锦上添花**:
7. S6 L 形（需要 mask，代码稍复杂）
8. 美化图表（统一字体、颜色方案）

---

## 参考资源（改代码时查）

| 需要查什么 | 去哪查 |
|------------|--------|
| Robin BC ghost point 推导 | 现有 `pde_2d_model.py` 第 128-166 行已经写好了，照着改 |
| 窗户的 h 值选多少 | 墙 h≈0.5, 单层窗 h≈2.5, 双层窗 h≈1.0 (参考 MEP Academy) |
| numpy broadcast 数组乘法 | h_south 是 shape (nx,), T[1:-1, 0] 也是 shape (nx-2,), 用 h_south[1:-1] 切片即可 |
| L 形 mask 怎么处理角点 | mask 边界处的网格点当作内部 Robin BC（h = h_wall），最简单的处理 |
| solve_ivp 参数 | 现有代码已经配好了，不用改 |
